# SNHU-CS-320

To make sure my code, program, or software is functional and secure, I focus heavily on thorough testing and validation. Writing unit tests for each feature, like I did in Project One with the contact, task, and appointment services, helps me confirm that each part of the code behaves the way it’s supposed to. I also make it a habit to test for invalid inputs and edge cases, not just the expected ones, because unexpected behavior is often where security issues or bugs can hide. In future projects, I plan to build on this by also incorporating static analysis tools and code reviews to catch issues earlier in development.

When it comes to interpreting user needs and incorporating them into a program, I’ve learned that it’s important to stay focused on the specific requirements given, but also to think carefully about edge cases the user might not directly mention. In both projects, I broke down the requirements into smaller, testable goals, making it easier to track what needed to be built and tested. I realized that asking questions, like what could go wrong if a field isn’t validated, is just as important as following the initial instructions.

My approach to designing software is to start by fully understanding the problem and then break it down into small, manageable pieces. Before coding anything, I think through how different parts of the system will interact, what data each part will need, and where problems could happen. This cautious and methodical approach helped me a lot during Project Two when reflecting on how testing techniques support good design. I’ve learned that good design isn’t just about making things work, but making sure they are easy to test, maintain, and improve over time.
